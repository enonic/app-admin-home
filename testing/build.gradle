import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

plugins {
    id 'base'
    alias( libs.plugins.enonic.xp.base )
    alias( libs.plugins.node.gradle )
}

group = 'com.enonic.xp.js_testing'

repositories {
    mavenLocal()
    mavenCentral()
    xp.enonicRepo( 'dev' )
}

configurations {
    distro
    apps {
        transitive = false
    }
}

def unpackDir = layout.buildDirectory.dir( 'install' ).get()
def distroDir = unpackDir.dir( "enonic-xp-generic-$version" )
def xpHome = distroDir.dir('home')

dependencies {
    distro "com.enonic.xp:enonic-xp-generic:${version}@tgz"
}

def process

// Setup tasks
tasks.register( 'unpackDistro', Copy ) {
    description = 'Unpacks the XP distribution for testing'
    group = 'Test Setup'

    from {
        configurations.distro.collect { tarTree( it ) }
    }
    into unpackDir
}

tasks.register( 'copyConfig', Copy ) {
    description = 'Copy common configuration files'
    group = 'setup'

    from layout.projectDirectory.dir('test-config/common-config')
    include '**.*.cfg'
    include '*.properties'
    into xpHome.dir('config')
    mustRunAfter tasks.named( 'unpackDistro' )
}

tasks.register( 'downloadApps', Copy ) {
    description = 'Download test applications'
    group = 'setup'

    from {
        configurations.apps
    }
    into xpHome.dir( 'deploy' )
    mustRunAfter tasks.named( 'unpackDistro' )
}

tasks.register( 'deployApp', DefaultTask ) {
    description = 'Deploy the main application'
    group = 'setup'
    def appName = rootProject.tasks.named("jar", Jar).get().archiveBaseName.get()
    def appFile = distroDir.file("system/40/${appName}-${version}.jar").asFile

    outputs.files( appFile )
    outputs.upToDateWhen { false }
    doLast {
        def appUrl = (findProperty('appUrl') ?: "file:///$rootDir/build/libs/${appName}.jar") as String

        println "Deleting ${appFile}. Exists ${appFile.exists()}"
        appFile.delete()

        println "Copying from ${appUrl} to ${appFile}"
        uri( appUrl ).toURL().withInputStream { i -> appFile.withOutputStream { it << i } }
    }
    mustRunAfter tasks.named( 'unpackDistro' )
}

// Server management tasks
tasks.register( 'startServer' ) {
    description = 'Starts the XP server for testing'
    group = 'Test Execution'
    dependsOn tasks.named( 'unpackDistro' )
    doLast {
        logger.lifecycle( 'Starting XP Server at: {}', xpHome )
        logger.lifecycle( 'Server logs will be written to: build/reports/logs/xp.log' )
        def pb
        if ( DefaultNativePlatform.getCurrentOperatingSystem().windows ) {
            pb = new ProcessBuilder( 'cmd', '/c', "${distroDir}\\bin\\server.bat" )
        }
        else {
            pb = new ProcessBuilder( "${distroDir}/bin/server.sh" )
        }
        Map<String, String> env = pb.environment()
        env.put( 'XP_HOME', "${xpHome}".toString() )

        def logsPath = layout.buildDirectory.dir( 'reports/logs' ).get()
        mkdir logsPath.asFile
        pb.redirectOutput( logsPath.file( 'xp.log' ).asFile )
        pb.redirectErrorStream( true )
        process = pb.start()
    }
}

tasks.register( 'waitForServer') {
    doLast {
        long maxWaitMs = 60000
        long deadline = System.nanoTime() + maxWaitMs * 1_000_000L

        boolean ready = false
        while (!ready && System.nanoTime() < deadline) {
            logger.lifecycle("Waiting for server server...")

            try {
                HttpURLConnection conn = (HttpURLConnection) uri("http://localhost:2609/ready").toURL().openConnection()
                conn.setConnectTimeout(1000)
                conn.setReadTimeout(1000)
                conn.connect()
                int code = conn.getResponseCode()
                if (code == 200) {
                    ready = true
                    break
                }
            } catch (IOException ignored) {
                // Not up yet; retry
            }
            sleep(1000)

        }
        if (ready) {
            logger.lifecycle('Server is ready.')
        } else {
            throw new GradleException("Server not ready after ${maxWaitMs} ms.")
        }

        sleep(1000)
    }
}

tasks.register( 'stopServer' ) {
    description = 'Stops the XP server'
    group = 'Test Execution'
    doLast {
        if ( !project.hasProperty( 'process' ) ) {
            logger.warn( 'Server process not found - it might already be stopped' )
            return
        }

        def os = DefaultNativePlatform.currentOperatingSystem
        def pid = process.pid()

        if ( os.isWindows() ) {
            logger.lifecycle( "Stopping server process (PID: ${pid})..." )
            exec {
                commandLine 'taskkill', '/F', '/T', '/PID', pid.toString()
                ignoreExitValue = true // Don't fail if the process is already gone
            }
        } else { // For macOS, Linux, and other Unix-like systems
            logger.lifecycle( "Stopping server process (PID: ${pid})..." )
            exec {
                commandLine 'kill', '-9', pid.toString()
                ignoreExitValue = true // Don't fail if the process is already gone
            }
        }

        // Clean up the process property
        project.ext.process = null
    }
}

tasks.register( 'cleanup', Delete ) {
    description = 'Clean up test reports'
    group = 'verification'

    delete layout.buildDirectory.dir('reports/allure')
}

tasks.register( 'generateReportAndStopServer', PnpmTask ) {
    description = 'Generates test report and stops server'
    group = 'Test Reporting'
    args = ['--color', 'run', 'allure-report']
    finalizedBy tasks.named( 'cleanup' )
    finalizedBy tasks.named( 'stopServer' )
}

// Test execution tasks
tasks.register( 'w_testAdminHomeChrome', PnpmTask ) {
    description = 'Run application tests in Chrome'
    group = 'verification'

    dependsOn tasks.named( 'pnpmInstall' )
    dependsOn tasks.named( 'unpackDistro' )
    dependsOn tasks.named( 'copyConfig' )
    dependsOn tasks.named( 'downloadApps' )
    dependsOn tasks.named( 'deployApp' )
    dependsOn tasks.named( 'startServer' )
    dependsOn tasks.named( 'waitForServer' )
    args = ['--color', 'run', 'test_admin_home:wdio_chrome']
    finalizedBy tasks.named( 'generateReportAndStopServer' )
}

tasks.register( 'w_testAdminHomeChromeLocal', PnpmTask ) {
    description = 'Run application tests in Chrome locally'
    group = 'verification'

    dependsOn tasks.named( 'pnpmInstall' )
    args = ['--color', 'run', 'test_admin_home:wdio_chrome']
}

tasks.register( 'yolo' ) {
    group = 'Other'
}
